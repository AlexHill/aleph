<html>
  <head>
    <title>aleph.http API reference (aleph)</title>
    <link href="static/favicon.png" rel="icon" />
    <link href="static/favicon.png" rel="shortcut icon" />
    <link media="all" type="text/css" href="static/clojure.css" rel="stylesheet" />
    <link media="all" type="text/css" href="static/wiki.css" rel="stylesheet" />
    <link media="all" type="text/css" href="static/internal.css" rel="stylesheet" />
    <!-- TODO: are we using these (from clojure.org)? If so, add the files -->
    <script src="file/view/code_highlighter.js" type="text/javascript"></script>
    <script src="file/view/clojure.js" type="text/javascript"></script>
    <style>.menuWrapper{height: 36px;}</style>
    <!--[if lte IE 6]>
    <link rel="stylesheet" href="http://www.wikispaces.com/_/2009051601/s/internal_ie.css" type="text/css" />
    <![endif]-->
  </head>
<!--
This document was auto-generated from the source by the clojure autodoc system.
To report errors or ask questions about the overall documentation structure, formatting,
etc., contact Tom Faulhaber (google mail name: tomfaulhaber).
For errors in the documentation of a particular namespace, contact the author of that
namespace.
-->
  <body>
    <div id="AllContentContainer">
      <div id="Header">
	<a id="Logo" href="index.html"><img alt="Clojure" height="100" width="100" src="static/clojure-icon.gif" /></a>
	<h1><a title="page header title" id="page-header" href="index.html">aleph</a></h1>
      </div>
      <div id="leftcolumn"><div style="text-align: center;"></div>
<div class="menu">
  <div class="WikiCustomNav WikiElement wiki">
    <a class="wiki_link" href="index.html">Overview</a><br />
    <a class="wiki_link" href="api-index.html">API Index</a><br />
    <a class="wiki_link" href="#">Namespaces:</a>
    <ul id="left-sidebar-list">
      <li><a href="aleph.core-api.html" class="wiki_link">aleph.core</a></li><li><a href="aleph.formats-api.html" class="wiki_link">aleph.formats</a></li><li><a href="aleph.http-api.html" class="wiki_link">aleph.http</a></li><li><a href="aleph.object-api.html" class="wiki_link">aleph.object</a></li><li><a href="aleph.redis-api.html" class="wiki_link">aleph.redis</a></li><li><a href="aleph.tcp-api.html" class="wiki_link">aleph.tcp</a></li><li><a href="aleph.trace-api.html" class="wiki_link">aleph.trace</a></li><li><a href="aleph.udp-api.html" class="wiki_link">aleph.udp</a></li>
    </ul>
  </div>
</div>
</div>
      <div id="rightcolumn">
	<div id="Content">
	  <div class="contentBox"><div class="innerContentBox">
              <div id="content_view" class="wiki wikiPage">
                <div id="right-sidebar"><div id="toc">
  <h1 class="nopad">Table of Contents</h1>
  <div style="margin-left: 1em;" class="toc-section">
    <a href="#toc0">Overview</a>
    <div style="margin-left: 1em;" class="toc-entry">
      <a href="#aleph.http/http-client">http-client</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#aleph.http/http-request">http-request</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#aleph.http/pipelined-http-client">pipelined-http-client</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#aleph.http/request-body-&gt;input-stream">request-body-&gt;input-stream</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#aleph.http/request-client-info">request-client-info</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#aleph.http/request-cookie">request-cookie</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#aleph.http/request-params">request-params</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#aleph.http/start-http-server">start-http-server</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#aleph.http/sync-http-request">sync-http-request</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#aleph.http/wrap-aleph-handler">wrap-aleph-handler</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#aleph.http/wrap-ring-handler">wrap-ring-handler</a>
    </div>
    <br />
  </div><div style="margin-left: 1em;" class="toc-section">
    <a href="#aleph.http.server.requests">aleph.http.server.requests</a>
    <div style="margin-left: 1em;" class="toc-entry">
      <a href="#aleph.http.server.requests/transform-netty-request">transform-netty-request</a>
    </div>
    <br />
  </div><div style="margin-left: 1em;" class="toc-section">
    <a href="#aleph.http.server.responses">aleph.http.server.responses</a>
    <div style="margin-left: 1em;" class="toc-entry">
      <a href="#aleph.http.server.responses/transform-aleph-response">transform-aleph-response</a>
    </div>
    <br />
  </div><div style="margin-left: 1em;" class="toc-section">
    <a href="#aleph.http.websocket.protocol">aleph.http.websocket.protocol</a>
    <div style="margin-left: 1em;" class="toc-entry">
      <a href="#aleph.http.websocket.protocol/mask-buffers">mask-buffers</a>
    </div>
    <br />
  </div>
</div>
</div>
                <div id="content-tag"><h1 id="overview">API for <span id="namespace-name">aleph.http</span></h1>
by <span id="author">Zachary Tellman</span><br />
<br />Usage:
<pre>
(ns your-namespace
  (:require <span id="long-name">aleph.http</span>))
</pre><pre>
</pre><h2>Overview</h2>
<pre id="namespace-docstr"></pre>
<br />
<h2>Public Variables and Functions</h2>
<div id="var-entry">
  <br />
  <hr />
  <h2 id="aleph.http/http-client">http-client</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (http-client options)
</pre>
  <pre id="var-docstr">Returns a function which represents a persistent connection to the server specified by
:url.  The function will take an HTTP request per the Ring spec and optionally a timeout,
and returns a result-channel that will emit the HTTP response.  Redirects will not be
followed.

The connection can be closed using lamina.connections/close-connection.

Requests will only be sent to the server once the response to the previous request has
been received.  To make concurrent requests, open multiple clients.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="aleph.http/http-request">http-request</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (http-request request)
       (http-request request timeout)
</pre>
  <pre id="var-docstr">Takes an HTTP request structured per the Ring spec, and returns a result-channel
that will emit an HTTP response.  If a timeout is specified and elapses before a
response is received, the result will emit an error.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="aleph.http/pipelined-http-client">pipelined-http-client</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (pipelined-http-client options)
</pre>
  <pre id="var-docstr">Returns a function which represents a persistent connection to the server specified by
:url.  The function will take an HTTP request per the Ring spec and optionally a timeout,
and returns a result-channel that will emit the HTTP response.  Redirects will not be
followed.

The connection can be closed using lamina.connections/close-connection.

Requests will be sent to the server as soon as they are made, under the assumption that
responses will be sent in the same order.  This is not always a safe assumption (see
<a href="http://en.wikipedia.org/wiki/HTTP_pipelining">http://en.wikipedia.org/wiki/HTTP_pipelining</a> ), use only where you're sure the underlying
assumptions holds.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="aleph.http/request-body-&gt;input-stream">request-body-&gt;input-stream</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (request-body-&gt;input-stream request)
</pre>
  <pre id="var-docstr">Returns a result-channel which will emit the request with an InputStream or nil as the
body.

The result-channel will be immediately realized if the request is not chunked, but if
the request is chunked then synchronously waiting on the result inside the handler will
cause issues.  You may synchronously wait on the result in a different thread, but the
recommended approach is to structure your handler like:

(defn handler [ch request]
  (run-pipeline (request-body-&gt;input-stream request)
    (fn [request]
      ... middleware and routing goes here ...)))

or to use the (async ...) macro.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="aleph.http/request-client-info">request-client-info</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (request-client-info request)
</pre>
  <pre id="var-docstr">Returns information about the client, based on the 'User-Agent' header in the request.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="aleph.http/request-cookie">request-cookie</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (request-cookie request)
</pre>
  <pre id="var-docstr">Returns a hash of the values within the request's cookie.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="aleph.http/request-params">request-params</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (request-params request)
       (request-params request options)
</pre>
  <pre id="var-docstr">Returns a result-channel representing the merged query and body parameters in the request.

The result-channel will be immediately realized if the request is not chunked, but if the
request is chunked then synchronously waiting on the result inside the handler will cause
issues.  You may synchrously wait on the result in a different thread, but the recommended
approach is do something like:

(run-pipeline (request-params request)
  (fn [params]
    ... handle request here ...))

or to wrap your code in the (async ...) macro.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="aleph.http/start-http-server">start-http-server</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (start-http-server handler options)
</pre>
  <pre id="var-docstr">Starts an HTTP server on the specified :port.  To support WebSockets, set :websocket to
true.

'handler' should be a function that takes two parameters, a channel and a request hash.
The request is a hash that conforms to the Ring standard, with :websocket set to true
if it is a WebSocket handshake.  If the request is chunked, the :body will also be a
channel.

If the request is a standard HTTP request, the channel will accept a single message, which
is the response.  For a chunked response, the response :body should be a channel.  If the
request is a WebSocket handshake, the channel represents a full duplex socket, which
communicates via complete (i.e. non-streaming) strings.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="aleph.http/sync-http-request">sync-http-request</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (sync-http-request request)
       (sync-http-request request timeout)
</pre>
  <pre id="var-docstr">A synchronous version of http-request.  Halts the thread until the response has returned,
and throws an exception if the timeout elapsed or another error occurred.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="aleph.http/wrap-aleph-handler">wrap-aleph-handler</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (wrap-aleph-handler f)
</pre>
  <pre id="var-docstr">Allows for an asynchronous handler to be used within a largely synchronous application.
Assuming the top-level handler has been wrapped in wrap-ring-handler, this function can be
used to wrap handler functions for asynchronous routes.</pre>
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="aleph.http/wrap-ring-handler">wrap-ring-handler</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (wrap-ring-handler f)
</pre>
  <pre id="var-docstr">Wraps a synchronous Ring handler, such that it can be used in start-http-server.  If certain
routes within the application are asynchronous, wrap those handler functions in
wrap-aleph-handler.</pre>
  
</div>
<h2 id="namespace-name">aleph.http.server.requests</h2>
<pre id="namespace-docstr"></pre>
<br />
<div id="var-entry">
  <hr />
  <h2 id="aleph.http.server.requests/transform-netty-request">transform-netty-request</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (transform-netty-request req netty-channel options)
</pre>
  <pre id="var-docstr">Transforms a Netty request into a Ring request.</pre>
  
</div>
<h2 id="namespace-name">aleph.http.server.responses</h2>
<pre id="namespace-docstr"></pre>
<br />
<div id="var-entry">
  <hr />
  <h2 id="aleph.http.server.responses/transform-aleph-response">transform-aleph-response</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (transform-aleph-response response options)
</pre>
  <pre id="var-docstr">Turns a Ring response into something Netty can understand.</pre>
  
</div>
<h2 id="namespace-name">aleph.http.websocket.protocol</h2>
<pre id="namespace-docstr"></pre>
<br />
<div id="var-entry">
  <hr />
  <h2 id="aleph.http.websocket.protocol/mask-buffers">mask-buffers</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (mask-buffers mask bufs)
</pre>
  <pre id="var-docstr">Does an in-place masking of a sequence of ByteBuffers.</pre>
  
</div>


</div>
              </div>
            </div>
          </div>
	</div>
	<div id="foot">
	  <div style="text-align: center;" id="copyright">No copyright info </div>
	</div>
      </div>
      <div id="DesignedBy">Logo &amp; site design by <a title="Visit Tom Hickey's website." href="http://www.tomhickey.com">Tom Hickey</a>.<br />
      Clojure auto-documentation system by Tom Faulhaber.</div>
    </div>
    <!-- /AllContentContainer -->
  </body>

</html>